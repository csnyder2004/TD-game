<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jungle Tower Defense</title>
  <style>
    
    body {
      font-family: "Segoe UI", Arial, sans-serif;
      font-size: 15px;
      background-color: #111112;
      margin: 0;
      color: #cdf7b9;
    }

    #game-container {
      display: flex;
      margin: 20px auto;
      background: #7a83b5;
      box-shadow: 0 0 30px #223e1a;
      border: 6px solid #666863;
      border-radius: 12px;
      overflow: hidden;
      width: fit-content;
    }

    #game-area {
      flex: 0 0 auto;
    }

    #sidebar {
      flex: 0 0 200px; /* adjust as needed */
      background: #0b0b0f;
      padding: 16px;
      border-left: 2px solid #4b6d1d;
    }

    canvas {
      display: block;
      width: 900px;
      height: 600px;
      cursor: crosshair;
    }

    #ui {
      padding: 6px;
      background: #0b0b0f;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
      align-items: center;
      border-top: 2px solid #4b6d1d;
      box-shadow: 0 -3px 12px rgba(0,0,0,0.3);
    }


    #money-display,
    #lives-display,
    #wave-display,
    #enemies-left {
      font-weight: bold;
      font-size: 16px;
      text-align: center;
      color: #f0fff0;
      background: linear-gradient(#010101, #1d301d);
      border: 1px solid #567;
      border-radius: 2px;
      padding: 2px 2px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.4), inset 0 0 4px #113;
      display: block;
    }


    button {
      background: linear-gradient(to bottom, #03094f, #535272);
      border: none;
      border-radius: 6px;
      color: #fff;
      font-weight: 600;
      padding: 10px 16px;
      font-size: 15px;
      cursor: pointer;
      transition: background 0.25s, transform 0.2s ease;
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
    }

    button:hover {
      background: linear-gradient(to bottom, #6fa324, #4a6a18);
      transform: scale(1.05);
    }

    button:active {
      transform: scale(0.97);
      box-shadow: 0 2px 4px rgba(0,0,0,0.4);
    }


    #tower-menu {
      display: flex;
      flex-wrap: wrap;
      flex-direction: column;
      gap: 6px;
      max-width: 640px;
      justify-content: center;
    }

    #tower-preview {
      background: #121a33;
      border: 2px solid #cdf7b9;
      color: #cdf7b9;
      padding: 12px;
      border-radius: 10px;
      font-size: 14px;
      position: absolute;
      right: 12px;
      top: 12px;
      box-shadow: 0 0 10px rgba(0,0,0,0.7);
      min-width: 220px;
      max-width: 260px;
      z-index: 1000;
    }


    #tower-preview h3 {
      margin: 0;
      font-size: 16px;
      border-bottom: 1px solid #cdf7b944;
      padding-bottom: 4px;
    }

    #preview-stats {
      list-style-type: none;
      padding: 0;
      margin: 8px 0 0 0;
    }


    #upgrade-panel {
      background: #5c5c5e;
      border: 2px solid #cdf7b9;
      border-radius: 10px;
      padding: 12px;
      min-width: 260px;
      box-shadow: 0 0 12px #001;
      text-align: center;
      margin-top: 10px;
    }
    #upgrade-panel button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      width: 50%;
      margin: 6px 0;
    }




    #message-box {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(6, 6, 139, 0.7);
      color: #f9d71c;
      padding: 6px 12px;
      border-radius: 6px;
      font-weight: bold;
      font-size: 14px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      max-width: 90%;
      text-align: center;
      white-space: nowrap;
    }

    /* Tooltip */
    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: max-content;
      max-width: 200px;
      background-color: #2e3b11;
      color: #cdf7b9;
      text-align: left;
      border-radius: 6px;
      padding: 8px;
      border: 1px solid #cdf7b9;
      position: absolute;
      z-index: 999;
      bottom: 120%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s ease;
      font-size: 13px;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    /* UI layout rows */
    .ui-row {
      display: block;
      justify-content: center;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 12px;
    }

    /* Grid for tower buttons */
    .ui-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 10px;
      justify-content: center;
      width: 100%;
      max-width: 800px;
      margin: 0 auto 12px auto;
    }

    /* Tower buttons look consistent */
    #tower-menu button {
      width: 100%;
      padding: 10px;
      font-weight: bold;
    }


    #status-row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px; /* space between boxes */
      background: #1d1a37;
      border: 2px solid #4b6d1d;
      border-radius: 4px;
      padding: 4px 8px;
      box-shadow: inset 0 0 2px #000;
      margin: 0 auto 10px auto;
      max-width: fit-content;
    }


    /* Control buttons look consistent */
    #control-row button {
      min-width: 120px;
    }

    #control-row {
      display: block;
      flex-wrap: wrap;
      gap: 10px;
    }

    /* Add a game title */
    #game-title {
      text-align: center;
      font-size: 28px;
      font-weight: bold;
      color: #cdf7b9;
      margin-bottom: 16px;
      text-shadow: 0 2px 4px #000;
    }

    /* Upgrade panel: tidy grid */
    #upgrade-panel {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }


    #enemy-info-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #101738;
      border: 2px solid #cdf7b9;
      border-radius: 12px;
      padding: 20px;
      color: #cdf7b9;
      max-height: 80%;
      overflow-y: auto;
      box-shadow: 0 0 20px #000;
      z-index: 9999;
    }

    #enemy-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 12px;
    }

    .enemy-card {
      background: #090909;
      border: 1px solid #8f1111;
      border-radius: 8px;
      padding: 10px;
      text-align: center;
    }

    .enemy-card img {
      display: block;
      margin: 0 auto 8px;
      width: 64px;
      height: 64px;
      background: #000;
    }




  </style>

</head>
<body>



  <h1 id="game-title">üåø Cole's Tower Defense üåø

  </h1>

  <div id="status-row" class="ui-row">
      <div class="stat-box" id="money-display">üí∞ Money: 500</div>
      <div class="stat-box" id="lives-display">‚ù§Ô∏è Lives: 10</div>
      <div class="stat-box" id="wave-display">üåä Wave: 0</div>
      <div class="stat-box" id="enemies-left">üßü Enemies Left: 0</div>
    </div>








    <div id="game-container">
      <div id="game-area">
        <canvas id="gameCanvas" width="900" height="600"></canvas>
      </div>
      <div id="sidebar">
        <div id="tower-menu">
          <!-- Tower buttons -->
          <div class="tooltip">
            <button data-tower="basic">Basic Tower ($50)</button>
            <div class="tooltiptext">Reliable starter with average damage and speed.</div>
          </div>
          <div class="tooltip">
            <button data-tower="sniper">Sniper Tower ($120)</button>
            <div class="tooltiptext">Long-range, slow reload, high damage.</div>
          </div>
          <div class="tooltip">
            <button data-tower="cannon">Cannon Tower ($150)</button>
            <div class="tooltiptext">Deals splash damage in a small radius.</div>
          </div>
          <div class="tooltip">
            <button data-tower="flame">Flame Tower ($180)</button>
            <div class="tooltiptext">Rapid-fire burning damage over time.</div>
          </div>
          <div class="tooltip">
            <button data-tower="ice">Ice Tower ($200)</button>
            <div class="tooltiptext">Slows enemies and deals cold damage.</div>
          </div>
          <div class="tooltip">
            <button data-tower="tesla">Tesla Tower ($300)</button>
            <div class="tooltiptext">Hits multiple enemies with electricity.</div>
          </div>
          <div class="tooltip">
            <button data-tower="missile">Missile Tower ($350)</button>
            <div class="tooltiptext">Long range, powerful missiles.</div>
          </div>
          <div class="tooltip">
            <button data-tower="sniperElite">Sniper Elite ($400)</button>
            <div class="tooltiptext">Extreme range and high precision shots.</div>
          </div>
          <div class="tooltip">
            <button data-tower="Obsidian">Obsidian ($500)</button>
            <div class="tooltiptext">Burns enemies and adds fire DOT.</div>
          </div>
          <div class="tooltip">
            <button data-tower="Nova">Nova ($650)</button>
            <div class="tooltiptext">AOE pulse that hits all nearby enemies.</div>
          </div>
          <div class="tooltip">
            <button data-tower="poison">Poison ($250)</button>
            <div class="tooltiptext">Weak but cheap ‚Äî poisons enemies over time.</div>
          </div>
          <div class="tooltip">
            <button data-tower="railgun">Railgun ($800)</button>
            <div class="tooltiptext">Extreme power and range. Slow recharge.</div>
          </div>
          <div class="tooltip">
            <button data-tower="hyperLaser">HyperLaser ($4000)</button>
            <div class="tooltiptext">Ultra-fast laser tower with massive power.</div>
          </div>
          <div class="tooltip">
            <button data-tower="omegaCannon">Omega Cannon ($10000)</button>
            <div class="tooltiptext">Massive cannon with extreme power and blast radius.</div>
          </div>

        </div>
      </div>
    </div>

  <div id="message-box"></div>
    <div id="ui">
     
      <div id="control-row" class="ui-row">
        <button id="startBtn">Start Wave</button>
        <button id="stopBtn">Pause</button>
        <button id="autoBtn">Auto Start: ON</button>
        <button id="speedBtn">Speed: 1x</button>
        <button id="enemyInfoBtn">Enemy Info</button>
        <button id="cancelTowerBtn" style="position:absolute; bottom:10px; right:10px; z-index:20; padding:6px 12px;">
          ‚ùå Cancel Placement
        </button>




      </div>
    
        <div id="upgrade-panel">
          <div>
          <strong>Upgrade Tower</strong>
          <div id="upgrade-icons" style="margin-top:4px; font-size: 16px;"></div>
        </div>
        <label for="targetModeSelect">Targeting Mode:</label>
        <select id="targetModeSelect">
          <option value="first">First</option>
          <option value="last">Last</option>
          <option value="strong">Strong</option>
          <option value="close">Close</option>
        </select>
        <br>
        <button id="upgrade1Btn">Upgrade Path 1</button>
        <button id="upgrade2Btn">Upgrade Path 2</button>
        <button id="sellBtn">Sell Tower</button>
     
      </div>

      <div id="enemy-info-panel" style="display: none;">
        <h3>Enemy Types</h3>
        <div id="enemy-list"></div>
        <button id="closeEnemyInfoBtn">Close</button>
      </div>



      <div id="tower-preview" style="display: none;">
        <h3 id="preview-name"></h3>
        <p id="preview-cost"></p>
        <ul id="preview-stats"></ul>
      </div>

  <script>
  (() => {
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const moneyDisplay = document.getElementById("money-display");
    const livesDisplay = document.getElementById("lives-display");
    const waveDisplay = document.getElementById("wave-display");
    const enemiesLeftDisplay = document.getElementById("enemies-left");
    const towerMenu = document.getElementById("tower-menu");
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const autoBtn = document.getElementById("autoBtn");
    const speedBtn = document.getElementById("speedBtn");
    const upgradePanel = document.getElementById("upgrade-panel");
    const upgrade1Btn = document.getElementById("upgrade1Btn");
    const upgrade2Btn = document.getElementById("upgrade2Btn");
    const sellBtn = document.getElementById("sellBtn");
    const messageBox = document.getElementById("message-box");

    let money = 500,
      lives = 10,
      waveNumber = 0,
      enemiesToSpawn = 0,
      spawning = false,
      spawnTimer = 0,
      gamePaused = false,
      autoStart = true,
      gameSpeed = 1,
      enemyTypes = ["normal", "fast"];

    let selectedTowerType = null,
      placingTower = false,
      selectedTower = null,
      hoveredTower = null;

    let placementX = 0, placementY = 0;


    let towers = [],
      enemies = [],
      bullets = [],
      effects = [];

      document.getElementById("cancelTowerBtn").addEventListener("click", () => {
        placingTower = false;
        selectedTowerType = null;
      });


    const towerCosts = {
      basic: 50,
      sniper: 120,
      cannon: 150,
      flame: 200,
      ice: 200,
      tesla: 300,
      missile: 350,
      sniperElite: 400,
      Obsidian: 500,
      Nova: 650,
      poison: 250,
      railgun: 800,
      hyperLaser: 4000,
      omegaCannon: 10000,
    };

    const upgradeEffects = {
      basic: [
        tower => { tower.reloadSpeed = Math.max(3, tower.reloadSpeed - 4); },
        tower => { tower.damage += 15; }
      ],
      sniper: [
        tower => { tower.range += 50; },
        tower => { tower.reloadSpeed = Math.max(5, tower.reloadSpeed - 10); }
      ],
      cannon: [
        tower => { tower.damage += 25; },
        tower => { tower.range += 25; }
      ],
      flame: [
        tower => {
          tower.damage += 7;
          tower.reloadSpeed = Math.max(2, tower.reloadSpeed - 2);
        },
        tower => {
          tower.range += 25;
          tower.damage += 3;
        }
      ],
      ice: [
        tower => { tower.reloadSpeed = Math.max(5, tower.reloadSpeed - 7); },
        tower => { tower.damage += 12; }
      ],
      tesla: [
        tower => { tower.range += 30; },
        tower => { tower.reloadSpeed = Math.max(6, tower.reloadSpeed - 6); }
      ],
      missile: [
        tower => { tower.damage += 30; },
        tower => { tower.reloadSpeed = Math.max(25, tower.reloadSpeed - 20); }
      ],
      sniperElite: [
        tower => { tower.range += 60; },
        tower => { tower.damage += 40; }
      ],
      Obsidian: [
        tower => { tower.reloadSpeed = Math.max(5, tower.reloadSpeed - 5); },
        tower => { tower.damage += 25; }
      ],
      Nova: [
        tower => { tower.range += 40; },
        tower => { tower.reloadSpeed = Math.max(10, tower.reloadSpeed - 8); }
      ],
      poison: [
        tower => { tower.range += 30; },
        tower => { tower.damage += 12; }
      ],
      railgun: [
        tower => { tower.damage += 150; },
        tower => { tower.reloadSpeed = Math.max(8, tower.reloadSpeed - 10); }
      ],
      hyperLaser: [
        tower => { tower.reloadSpeed = Math.max(0.5, tower.reloadSpeed - 1); }, // insanely fast
        tower => { tower.damage += 35; } // major damage boost
      ],
        omegaCannon: [
        tower => { tower.damage += 400; tower.range += 100; },
        tower => { tower.reloadSpeed = Math.max(5, tower.reloadSpeed - 10); }
      ],


    };



    const upgradeCosts = {
      basic: [30, 50],
      sniper: [60, 100],
      cannon: [70, 120],
      flame: [60, 100],
      ice: [70, 120],
      tesla: [100, 150],
      missile: [120, 180],
      sniperElite: [150, 220],
      Obsidian: [200, 300],
      Nova: [300, 400],
      poison: [70, 90],
      railgun: [400, 500],
      hyperLaser: [1200, 1800],
      omegaCannon: [2000, 3000],


    };

        // ---- ADD BELOW upgradeCosts ----
    const upgradePaths = {
      basic: { path1: ["+fireRate", "üîÅ"], path2: ["+damage", "üí•"] },
      sniper: { path1: ["+range", "üéØ"], path2: ["+damage", "üî•"] },
      cannon: { path1: ["+damage", "üí£"], path2: ["+range", "üìè"] },
      flame: { path1: ["+damage", "üî•"], path2: ["+range", "üå°Ô∏è"] },
      ice: { path1: ["+fireRate", "‚ùÑÔ∏è"], path2: ["+damage", "üßä"] },
      tesla: { path1: ["+range", "‚ö°"], path2: ["+fireRate", "üîã"] },
      missile: { path1: ["+damage", "üöÄ"], path2: ["+fireRate", "üß®"] },
      sniperElite: { path1: ["+range", "üßø"], path2: ["+damage", "üî´"] },
      Obsidian: { path1: ["+fireRate", "üî•"], path2: ["+damage", "üåã"] },
      Nova: { path1: ["+range", "üåü"], path2: ["+fireRate", "‚òÄÔ∏è"] },
      poison: { path1: ["+range", "‚ò†Ô∏è"], path2: ["+poison", "üß™"] },
      railgun: { path1: ["+damage", "üì°"], path2: ["+fireRate", "‚öôÔ∏è"] },
      hyperLaser: { path1: ["+fireRate", "üåû"], path2: ["+damage", "‚ö°"] },
      omegaCannon: { path1: ["+damage/range", "üí•"], path2: ["+fireRate", "‚ö°"] },


    };

    const upgradeDescriptions = {
      basic: [
        "Faster shooting speed", 
        "More powerful bullets"
      ],
      sniper: [
        "Increased range to snipe from afar", 
        "High-caliber rounds for double damage"
      ],
      cannon: [
        "Stronger explosion damage", 
        "Wider blast radius"
      ],
      flame: [
        "Hotter flames that burn faster", 
        "Extended flamethrower reach"
      ],
      ice: [
        "Rapid chilling for quick shots", 
        "Deeper freeze for more damage"
      ],
      tesla: [
        "Extended shock range", 
        "Faster energy bursts"
      ],
      missile: [
        "High-yield warheads", 
        "Rapid missile launch system"
      ],
      sniperElite: [
        "Extreme range vision", 
        "Armor-piercing shots"
      ],
      Obsidian: [
        "Faster burn rate", 
        "Eruptive lava damage"
      ],
      Nova: [
        "Wider blast radius", 
        "Blazing pulse frequency"
      ],
      poison: [
        "Longer poison spread", 
        "Toxic cloud damage over time"
      ],
      railgun: [
        "Overcharged beam damage", 
        "Faster beam recharge"
      ],
      hyperLaser: [
        "Ridiculously fast beam rate",
        "Supercharged beam damage"
      ],
        omegaCannon: [
        "Devastating blast with longer range",
        "Fires significantly faster"
      ],


    };













    function distance(x1, y1, x2, y2) {
      return Math.hypot(x2 - x1, y2 - y1);
    }

    function showMessage(text, duration = 2000) {
      clearTimeout(messageBox.clearTimeout);
      messageBox.textContent = text;
      messageBox.style.opacity = "1";
      messageBox.clearTimeout = setTimeout(
        () => (messageBox.style.opacity = "0"),
        duration
      );
    }

    function updateDisplays() {
      moneyDisplay.textContent = `Money: ${money}`;
      livesDisplay.textContent = `Lives: ${lives}`;
      waveDisplay.textContent = `Wave: ${waveNumber}`;
      enemiesLeftDisplay.textContent = `Enemies Left: ${enemies.length + enemiesToSpawn}`;
    }

    function roundRect(ctx, x, y, w, h, r) {
      if (w < 2 * r) r = w / 2;
      if (h < 2 * r) r = h / 2;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }
    
    const backgroundImg = new Image();
    backgroundImg.src = 'backgroundimage/sprite.png';

    function drawGrassBackground() {
      if (backgroundImg.complete) {
        ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
      } else {
        backgroundImg.onload = () => {
          ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
        };
      }
    }



    const enemyPath = [
      { x: 0, y: 100 },
      { x: 850, y: 100 },
      { x: 850, y: 200 },
      { x: 100, y: 200 },
      { x: 100, y: 300 },
      { x: 850, y: 300 },
      { x: 850, y: 400 },
      { x: 100, y: 400 },
      { x: 100, y: 500 },
      { x: 850, y: 500 },
      { x: 850, y: 800 },
    ];



    const enemySprites = {};

    function generateEnemySprites() {
      const types = ["normal", "fast", "armoredBoss", "shielded", "regenerator", "flying", "titan", "specter", "inferno"];

      types.forEach(type => {
        const canvas = document.createElement("canvas");
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext("2d");
        ctx.translate(32, 32);

        // Core color palettes
        const colors = {
          normal:   ["#506830", "#344420", "#aacd6e"],
          fast:     ["#c0392b", "#7b241c", "#f1948a"],
          armoredBoss: ["#3a3a3a", "#555", "#aaa"],
          shielded: ["#4477aa", "#223344", "#88ccff"],
          regenerator: ["#33aa33", "#116611", "#88ff88"],
          flying:   ["#555577", "#333355", "#9999ff"],
          titan:    ["#444444", "#888888", "#e0e0e0"],
          specter:  ["#aaccff", "#ffffff55", "#ccddee"],
          inferno:  ["#cc5500", "#442200", "#ffaa33"]
        };

        const [base, shade, highlight] = colors[type] || ["#999", "#666", "#ccc"];

        ctx.fillStyle = shade;

        if (type === "normal") {
          // Light tank
          ctx.fillStyle = base;
          ctx.fillRect(-14, -10, 28, 20);
          ctx.fillStyle = shade;
          ctx.fillRect(-10, -4, 20, 8);
          ctx.fillStyle = highlight;
          ctx.fillRect(-2, -2, 4, 4);
        } else if (type === "fast") {
          // Military jeep
          ctx.fillStyle = base;
          ctx.fillRect(-12, -14, 24, 28);
          ctx.fillStyle = "#222";
          ctx.fillRect(-8, -6, 16, 12);
        } else if (type === "armoredBoss") {
          // Heavy tank with turret
          ctx.fillStyle = base;
          ctx.fillRect(-18, -12, 36, 24);
          ctx.fillStyle = "#222";
          ctx.fillRect(-6, -4, 12, 8);  // turret
          ctx.fillStyle = "#888";
          ctx.fillRect(6, -2, 10, 4);   // barrel
        } else if (type === "shielded") {
          // Tank with forcefield
          ctx.fillStyle = base;
          ctx.fillRect(-14, -10, 28, 20);
          ctx.strokeStyle = "#99ccff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(0, 0, 24, 0, Math.PI * 2);
          ctx.stroke();
        } else if (type === "regenerator") {
          // APC / Medtruck
          ctx.fillStyle = base;
          ctx.fillRect(-13, -13, 26, 26);
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(-5, -2, 10, 4);
          ctx.fillRect(-2, -5, 4, 10);
        } else if (type === "flying") {
          // Jet
          ctx.fillStyle = base;
          ctx.beginPath();
          ctx.moveTo(0, -20);
          ctx.lineTo(12, 12);
          ctx.lineTo(6, 6);
          ctx.lineTo(-6, 6);
          ctx.lineTo(-12, 12);
          ctx.closePath();
          ctx.fill();

          ctx.fillStyle = highlight;
          ctx.fillRect(-4, -12, 8, 6);
        } else if (type === "titan") {
          // Giant spaceship or dropship
          ctx.fillStyle = base;
          ctx.beginPath();
          ctx.ellipse(0, 0, 22, 16, 0, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = highlight;
          ctx.fillRect(-4, -4, 8, 8);
        } else if (type === "specter") {
          // Stealth drone
          ctx.globalAlpha = 0.6;
          ctx.fillStyle = base;
          ctx.beginPath();
          ctx.arc(0, 0, 14, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        } else if (type === "inferno") {
          // Flame mech or heat drone
          ctx.fillStyle = base;
          ctx.beginPath();
          ctx.arc(0, 0, 12, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#ffff33";
          ctx.beginPath();
          ctx.arc(0, 0, 4, 0, Math.PI * 2);
          ctx.fill();
        }

        const img = new Image();
        img.src = canvas.toDataURL();
        enemySprites[type] = img;
      });
    }

    generateEnemySprites();





    const bossSprite = new Image();

    function generateBossSprite() {
      const canvas = document.createElement("canvas");
      canvas.width = 128;
      canvas.height = 128;
      const ctx = canvas.getContext("2d");
      ctx.translate(64, 64);

      // Base body
      ctx.fillStyle = "#3a3a3a";
      ctx.beginPath();
      ctx.ellipse(0, 0, 48, 28, 0, 0, Math.PI * 2);
      ctx.fill();

      // Cockpit dome
      ctx.fillStyle = "#ccaa00";
      ctx.beginPath();
      ctx.arc(0, -20, 10, 0, Math.PI * 2);
      ctx.fill();

      // Wings
      ctx.fillStyle = "#555";
      ctx.fillRect(-60, -4, 20, 8); // left wing
      ctx.fillRect(40, -4, 20, 8);  // right wing

      // Engines
      ctx.fillStyle = "#222";
      ctx.beginPath();
      ctx.arc(-48, 12, 6, 0, Math.PI * 2);
      ctx.arc(48, 12, 6, 0, Math.PI * 2);
      ctx.fill();

      // Gun turrets
      ctx.fillStyle = "#777";
      ctx.fillRect(-6, 28, 12, 8);
      ctx.fillRect(-3, 36, 6, 10);

      // Light flicker (optional)
      ctx.fillStyle = "#ff2222";
      ctx.beginPath();
      ctx.arc(0, 0, 3, 0, Math.PI * 2);
      ctx.fill();

      bossSprite.src = canvas.toDataURL();
    }
    generateBossSprite();





   

    const towerSprites = {};

    function loadTowerSprites() {
      const types = Object.keys(towerCosts);
      types.forEach(type => {
        const img = new Image();
        // Loads: towerimages/basictower/sprite.png, snipertower, flametower, etc.
        img.src = `towerimages/${type}tower/sprite.png`;

        img.onload = () => console.log(`‚úÖ Loaded: ${img.src}`);
        img.onerror = () => console.warn(`‚ö†Ô∏è Could not load: ${img.src}`);

        towerSprites[type] = img;
      });
    }

    loadTowerSprites();







    class Tower {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.level = 1;
        this.reloadTimer = 0;
        this.rotation = 0;
        this.targetMode = "first"; // default mode
        switch (type) {
          case "basic":
            this.range = 100;
            this.damage = 15;
            this.reloadSpeed = 15;
            this.upgrades = { path1: 0, path2: 0 };
            this.size =100;
            break;
          case "sniper":
            this.range = 200;
            this.damage = 40;
            this.reloadSpeed = 40;
            this.upgrades = { path1: 0, path2: 0 };
            this.size =100;
            break;
          case "cannon":
            this.range = 120;
            this.damage = 40;
            this.reloadSpeed = 25;
            this.upgrades = { path1: 0, path2: 0 };
            this.size =105;
            break;
          case "flame":
            this.range = 80;
            this.damage = 10;
            this.reloadSpeed = 5;
            this.upgrades = { path1: 0, path2: 0 };
            this.size =75;
            break;
          case "ice":
            this.range = 90;
            this.damage = 5;
            this.reloadSpeed = 20;
            this.upgrades = { path1: 0, path2: 0 };
            this.size =80;
            break;
          case "tesla":
            this.range = 110;
            this.damage = 35;
            this.reloadSpeed = 15;
            this.upgrades = { path1: 0, path2: 0 };
            this.size =90;
            break;
          case "missile":
            this.range = 160;
            this.damage = 50;
            this.reloadSpeed = 50;
            this.upgrades = { path1: 0, path2: 0 };
            this.size =90;
            break;
          case "sniperElite":
            this.range = 250;
            this.damage = 70;
            this.reloadSpeed = 30;
            this.upgrades = { path1: 0, path2: 0 };
            this.size =90;
            break;
          case "Obsidian":
            this.range = 160;
            this.damage = 40;
            this.reloadSpeed = 12;
            this.upgrades = { path1: 0, path2: 0 };
            this.size =90;
            break;
          case "Nova":
            this.range = 100;
            this.damage = 60;
            this.reloadSpeed = 20;
            this.fireCooldown = 0;
            this.upgrades = { path1: 0, path2: 0 };
            this.size =65;
            break;
          case "poison":
            this.range = 100;
            this.damage = 10;
            this.reloadSpeed = 20;
            this.upgrades = { path1: 0, path2: 0 };
            this.size =75;
            break;
          case "railgun":
            this.range = 400;
            this.damage = 200;
            this.reloadSpeed = 100;
            this.upgrades = { path1: 0, path2: 0 };
            this.size =115;
            break;
          case "hyperLaser":
            this.range = 280;
            this.damage = 65;
            this.reloadSpeed = 2;
            this.upgrades = { path1: 0, path2: 0 };
            this.size = 100;
            break;
          case "omegaCannon":
            this.range = 280;
            this.damage = 800;
            this.reloadSpeed = 20;
            this.upgrades = { path1: 0, path2: 0 };
            this.size = 120;
            break;



        }
      }
      update() {
        this.reloadTimer += gameSpeed;
        if (this.fireCooldown > 0) this.fireCooldown -= gameSpeed;
        if (this.reloadTimer >= this.reloadSpeed) {
          this.reloadTimer = 0;
          let inRange = enemies.filter(
            (e) => !e.dead && distance(this.x, this.y, e.x, e.y) <= this.range
          );

          let target = null;

          if (inRange.length > 0) {
            switch (this.targetMode) {
              case "first":
                target = inRange.reduce((a, b) =>
                  a.currentPathIndex > b.currentPathIndex ? a : b
                );
                break;
              case "last":
                target = inRange.reduce((a, b) =>
                  a.currentPathIndex < b.currentPathIndex ? a : b
                );
                break;
              case "strong":
                target = inRange.reduce((a, b) => (a.health > b.health ? a : b));
                break;
              case "close":
                target = inRange.reduce((a, b) =>
                  distance(this.x, this.y, a.x, a.y) < distance(this.x, this.y, b.x, b.y)
                    ? a
                    : b
                );
                break;
            }
          }

          if (target) {
            this.rotation = Math.atan2(target.y - this.y, target.x - this.x);
            switch (this.type) {
              case "flame":
                target.health -= this.damage * 0.5;
                break;
              case "ice":
                if (!target.slowTimer) {
                  target.originalSpeed = target.speed;
                  target.speed *= 0.03;
                  target.slowTimer = 60;
                }
                target.health -= this.damage * 0.8;
                break;
              case "tesla":
                enemies.forEach((e) => {
                  if ( !e.dead && distance(e.x, e.y, target.x, target.y) < 40 ) {
                    e.health -= this.damage;
                  }
                });
                break;






              case "Obsidian":
                target.health -= this.damage;

                // Burn effect: adds a burn property to the enemy
                if (!target.burn) {
                  target.burn = {
                    damagePerSecond: 5,
                    duration: 3, // seconds
                    elapsed: 0,
                  };
                }
                effects.push(new BurnEffect(target.x, target.y));
                break;
              case "poison":
                target.health -= this.damage * 0.3;
                if (!target.poison) {
                  target.poison = { dps: 4, duration: 4, elapsed: 0 };
                }
                break;
              case "Nova":

                if (this.fireCooldown <= 0) {
                    enemies.forEach((enemy) => {
                      const dx = enemy.x - this.x;
                      const dy = enemy.y - this.y;
                      const dist = Math.sqrt(dx * dx + dy * dy);
                      if (dist <= this.range) {
                        enemy.health -= this.damage;
                      }
                    });
                    this.fireCooldown = this.reloadSpeed;
                    effects.push(new SunBeamEffect(this.x, this.y)); // üî• Add beam visual
                  }
                  break;
              default:

                console.log("‚úÖ Bullet fired", this.x, this.y, "Type:", this.type);
                bullets.push(
                  new Bullet(this.x, this.y, target, this.damage, this.rotation, this.type)
                );
            }
            effects.push(new RecoilBlast(this.x, this.y, this.rotation));
          }
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        if (towerSprites[this.type] && towerSprites[this.type].complete) {
          ctx.drawImage(
            towerSprites[this.type],
            -this.size / 2,
            -this.size / 2,
            this.size,
            this.size
          );

        } else {
          console.warn(`‚ö†Ô∏è Missing sprite for: ${this.type}`);
          ctx.fillStyle = "#999";
          ctx.fillRect(-16, -16, 32, 32); // fallback box
        }

        ctx.restore();

        // Draw level label
        ctx.fillStyle = "#cdf7b9";
        ctx.font = "bold 16px Arial";
        ctx.textAlign = "center";
        ctx.fillText(`Lv.${this.level}`, this.x, this.y + 40);


        // Draw range ring if hovered or selected
        if (this === hoveredTower || this === selectedTower) {
          ctx.save();
          ctx.strokeStyle = this === selectedTower ? "#cdf7b9" : "rgba(205,247,185,0.5)";
          ctx.setLineDash([8, 8]);
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
          ctx.stroke();

          // upgrade icons
          const up = this.upgrades;
          const icons = [];
          if (up.path1 > 0) icons.push(upgradePaths[this.type].path1[1]);
          if (up.path2 > 0) icons.push(upgradePaths[this.type].path2[1]);
          ctx.fillStyle = "#fff";
          ctx.font = "bold 12px Arial";
          ctx.textAlign = "center";
          icons.forEach((ico, i) => {
            ctx.fillText(ico, this.x, this.y - 25 - i * 14);
          });

          ctx.restore();
        }
      }



    }


    class Bullet {
      constructor(x, y, target, damage, angle, type = "default") {
        this.x = x;
        this.y = y;
        this.startX = x;
        this.startY = y;
        this.target = target;
        this.damage = damage;
        this.angle = angle;
        this.speed = (type === "sniperElite") ? 6 : 12;
        this.dead = false;
        this.type = type;
        if (type === "hyperLaser") {
          this.pierceCount = 4;
          this.maxDistance = 800;
          this.speed = 16;
        } else if (type === "railgun" || type === "sniperElite") {
          this.pierceCount = 2;
          this.maxDistance = 600;
          this.speed = 6;
        } else {
          this.pierceCount = 1;
          this.maxDistance = 9999;
          this.speed = 12;
        }
        this.traveled = 0;
        this.maxDistance = (type === "railgun") ? 600 : 9999;
        this.hitEnemies = new Set();
        this.framesAlive = 0;
        this.hitDetected = false;

      }

      update() {
        this.framesAlive++;
        if (this.dead) return;

        if (!this.target || this.target.dead) {
          this.dead = true;
          return;
        }
        // Move bullet
          const dx = this.target.x - this.x;
          const dy = this.target.y - this.y;
          const dist = Math.hypot(dx, dy);

          const travel = this.speed * gameSpeed;





          if (this.type === "hyperLaser") {
            enemies.forEach(enemy => {
              if (!enemy.dead && !this.hitEnemies.has(enemy)) {
                const d = distance(this.x, this.y, enemy.x, enemy.y);
                if (d < (enemy.hitRadius || 16)) {
                  enemy.health -= this.damage;
                  this.hitEnemies.add(enemy);
                  effects.push(new RecoilBlast(this.x, this.y, this.angle));
                  if (this.hitEnemies.size >= this.pierceCount) {
                    this.dead = true;
                  }
                }
              }
            });
          } else if (dist <= travel + (this.target.hitRadius || 16)) {
            // Standard hit logic
            this.hitDetected = true;

            switch (this.type) {
              case "cannon":
                enemies.forEach(e => {
                  const d2 = distance(this.x, this.y, e.x, e.y);
                  if (d2 < 40 && !e.dead) {
                    e.health -= this.damage * (1 - d2 / 40);
                  }
                });
                break;
              case "poison":
                this.target.health -= this.damage;
                if (!this.target.poison) {
                  this.target.poison = { dps: 4, duration: 4, elapsed: 0 };
                }
                break;
              case "ice":
                this.target.health -= this.damage;
                if (!this.target.slowTimer) {
                  this.target.originalSpeed = this.target.speed;
                  this.target.speed *= 0.6;
                  this.target.slowTimer = 90;
                }
                break;
              case "Obsidian":
                this.target.health -= this.damage;
                if (!this.target.burn) {
                  this.target.burn = {
                    damagePerSecond: 5,
                    duration: 3,
                    elapsed: 0,
                  };
                }
                effects.push(new BurnEffect(this.x, this.y));
                break;

              case "omegaCannon":
                enemies.forEach(e => {
                  if (!e.dead && distance(this.x, this.y, this.target.x, this.target.y) < 100) {
                    e.health -= this.damage;
                    effects.push(new RecoilBlast(e.x, e.y, this.angle));
                  }
                });
                break;




              default:
                this.target.health -= this.damage;
                break;
            }

            effects.push(new RecoilBlast(this.x, this.y, this.angle));
            this.dead = true;
            return;
          }
          
            // Otherwise, move toward target
          this.x += (dx / dist) * travel;
          this.y += (dy / dist) * travel;

          // Optional: bullet lifetime limit
          this.traveled += travel;
          if (this.traveled > this.maxDistance) this.dead = true;
        }


      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(0, 0, 3, 0, Math.PI * 2);
        ctx.fill();

        console.log("Drawing bullet:", this.type, this.x, this.y);

        switch (this.type) {
          case "sniper":
            ctx.strokeStyle = "#00f";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(14, 0);
            ctx.stroke();
            break;
          case "cannon":
            ctx.fillStyle = "#f00";
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.fill();
            break;
          case "missile":
            ctx.fillStyle = "#aaa";
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(12, -3);
            ctx.lineTo(12, 3);
            ctx.closePath();
            ctx.fill();
            break;
          case "poison":
            ctx.fillStyle = "green";
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.fill();
            break;
          case "ice":
            ctx.fillStyle = "#00ffff";
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.fill();
            break;
          case "railgun":
            ctx.strokeStyle = "#99f";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-10, 0);
            ctx.lineTo(10, 0);
            ctx.stroke();
            break;
          case "basic":
            ctx.fillStyle = "#ffcc00";
            ctx.fillRect(0, -2, 10, 4);
            break;
          case "flame":
            ctx.fillStyle = "orange";
            ctx.beginPath();
            ctx.arc(0, 0, 3 + Math.random() * 2, 0, Math.PI * 2);
            ctx.fill();
            break;
          case "tesla":
            ctx.strokeStyle = "#ffff00";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-4, -4);
            ctx.lineTo(4, 4);
            ctx.moveTo(-4, 4);
            ctx.lineTo(4, -4);
            ctx.stroke();
            break;
          case "sniperElite":
            ctx.strokeStyle = "#ff00ff";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(16, 0);
            ctx.stroke();
            break;
          case "Obsidian":
            ctx.fillStyle = "#a83232";
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#ff6600";
            ctx.beginPath();
            ctx.arc(0, 0, 2, 0, Math.PI * 2);
            ctx.fill();
            break;
          case "Nova":
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(0, 0, 5 + Math.sin(Date.now() / 50) * 2, 0, Math.PI * 2);
            ctx.fill();
            break;
          case "hyperLaser":
            // Glowing electric beam core
            ctx.strokeStyle = "#ffff66";
            ctx.lineWidth = 3 + Math.sin(this.framesAlive * 0.6); // pulsates
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(24, (Math.random() - 0.5) * 2); // slight horizontal jitter
            ctx.stroke();

            // Outer blue glow
            ctx.strokeStyle = "rgba(100,200,255,0.4)";
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(24, (Math.random() - 0.5) * 2);
            ctx.stroke();

            // Electric sparks
            for (let i = 0; i < 2; i++) {
              ctx.strokeStyle = `rgba(255,255,255,${0.3 + Math.random() * 0.3})`;
              ctx.beginPath();
              ctx.moveTo(8 + Math.random() * 8, -1 + Math.random() * 2);
              ctx.lineTo(8 + Math.random() * 8, -6 + Math.random() * 12);
              ctx.stroke();
            }

            // Core orb at origin
            ctx.fillStyle = "#ffffcc";
            ctx.beginPath();
            ctx.arc(0, 0, 3 + Math.sin(this.framesAlive * 0.4), 0, Math.PI * 2);
            ctx.fill();
            break;

          case "omegaCannon":
            // Glowing charged shell core
            const gradient = ctx.createRadialGradient(0, 0, 2, 0, 0, 12);
            gradient.addColorStop(0, "#fff");
            gradient.addColorStop(0.3, "#99f");
            gradient.addColorStop(0.6, "#33f");
            gradient.addColorStop(1, "#001133");
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.fill();

            // Outer pulse ring
            ctx.strokeStyle = "rgba(100,150,255,0.4)";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, 18 + Math.sin(this.framesAlive * 0.4) * 2, 0, Math.PI * 2);
            ctx.stroke();

            // Barrel glow line
            ctx.strokeStyle = "#ccf";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-14, 0);
            ctx.lineTo(14, 0);
            ctx.stroke();

            // Shockwave ripple (optional visual)
            ctx.beginPath();
            ctx.arc(0, 0, 6 + Math.sin(this.framesAlive / 3) * 2, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(255,255,255,0.1)";
            ctx.lineWidth = 1;
            ctx.stroke();
            break;



          default:
            ctx.fillStyle = "#ffcc00";
            ctx.fillRect(0, -2, 10, 4);
            break;
        }
        ctx.restore();
      }
    }




    class Enemy {
      constructor(path, type, waveNumber = 1) {
        this.path = path;
        this.type = type;
        this.currentPathIndex = 0;
        this.x = path[0].x;
        this.y = path[0].y;
        this.hitRadius = this.type === "titan" ? 50 : 16;
        this.dead = false;
        switch (type) {
          case "fast":
            this.speed = 2.2 + 0.2 * waveNumber;
            this.health = 40 + 7 * waveNumber;
            break;
          case "armoredBoss":
            this.speed = 0.8 + 0.2 * waveNumber;
            this.health = 200 + 7 * waveNumber;
            break;
          case "shielded":
            this.speed = 1.2 + 0.2 * waveNumber;
            this.health = 150 + 7 * waveNumber;
            break;
          case "regenerator":
            this.speed = 1 + 0.2 * waveNumber;
            this.health = 80 + 7 * waveNumber;
            this.regenRate = 0.3;
            break;
          case "flying":
            this.speed = 1.8 + 0.2 * waveNumber;
            this.health = 50 + 7 * waveNumber;
            break;
          case "titan":
            this.speed = 0.4 + 0.02 * waveNumber;
            this.health = 10000 + waveNumber * 700;
            this.hitRadius = 24;
            this.reward = 50 + waveNumber * 5;
            break;
          case "specter":
            this.speed = 2.5 + 0.2 * waveNumber;
            this.health = 100 + 7 * waveNumber;
            this.evasive = true;
            break;
          case "inferno":
            this.speed = 1.2 + 0.2 * waveNumber;
            this.health = 300 + 7 * waveNumber;
            this.burnAura = true;
            break;
          default:
            this.speed = 1 + 0.1 * waveNumber;
            this.health = 50 + 5 * waveNumber;
            this.reward = 5;
        }
        this.maxHealth = this.health;
      }

      update() {
        if (this.dead) return;
        const target = this.path[this.currentPathIndex + 1];
        if (!target) {
          this.dead = true;
          lives--;
          showMessage("Enemy escaped! -1 Life", 1500);

          // ‚úÖ Immediately remove this enemy from the enemies[] array
          const index = enemies.indexOf(this);
          if (index !== -1) enemies.splice(index, 1);

          return;
        }


        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const dist = Math.hypot(dx, dy);

        // For Specter evasion:
        if (this.evasive && Math.random() < 0.2) return; // 20% chance to dodge

        // For Inferno burn aura:
        if (this.burnAura) {
          towers.forEach(t => {
            if (distance(this.x, this.y, t.x, t.y) < 50) {
              t.reloadSpeed += 0.05 * gameSpeed; // make them slower
            }
          });
        }

        if (dist < this.speed * gameSpeed) {
          this.x = target.x;
          this.y = target.y;
          this.currentPathIndex++;
        } else {
          this.x += (dx / dist) * this.speed * gameSpeed;
          this.y += (dy / dist) * this.speed * gameSpeed;
        }


        if (this.type === "regenerator") {
          this.health = Math.min(this.maxHealth, this.health + this.regenRate * gameSpeed);
        }

        if (this.poison) {
          this.poison.elapsed += gameSpeed;
          if (this.poison.elapsed % 20 === 0) {
            this.health -= this.poison.dps / 3;
          }
          this.poison.duration -= gameSpeed;
          if (this.poison.duration <= 0) delete this.poison;
        }


        if (this.slowTimer) {
          this.slowTimer -= gameSpeed;
          if (this.slowTimer <= 0) {
            this.speed = this.originalSpeed;
            delete this.slowTimer;
          }
        }

        // Apply burn damage over time
        if (this.burn) {
          this.burn.elapsed += gameSpeed;
          if (this.burn.elapsed % 20 === 0) {
            this.health -= this.burn.damagePerSecond / 3; // Spread over frames
          }
          this.burn.duration -= gameSpeed;
          if (this.burn.duration <= 0) {
            delete this.burn;
          }
        }

        if (this.health <= 0) {
          this.dead = true;
          const reward = this.reward || 5;
          money += reward;
          showMessage(`+${reward} Gold!`, 1000);
        }

      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // Rotate to face next path target
        const next = this.path[this.currentPathIndex + 1];
        if (next) {
          const dx = next.x - this.x;
          const dy = next.y - this.y;
          ctx.rotate(Math.atan2(dy, dx));
        }

        // Flash red briefly when damaged
        if (this._flashTimer && this._flashTimer > 0) {
          ctx.globalAlpha = 0.6;
          ctx.fillStyle = "red";
          ctx.beginPath();
          ctx.arc(0, 0, this.hitRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
          this._flashTimer -= gameSpeed;
        }

        const sprite = enemySprites[this.type];
        if (sprite) {
          ctx.drawImage(sprite, -32, -32, 64, 64);
        }



        if (this.type === "titan") {
          ctx.drawImage(sprite, -64, -64, 128, 128); // bigger draw
        } else {
          ctx.drawImage(sprite, -32, -32, 64, 64);
        }




        // Add a glow if shielded or regen
        if (this.type === "shielded") {
          ctx.strokeStyle = "rgba(100,200,255,0.5)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(0, 0, this.hitRadius + 4, 0, Math.PI * 2);
          ctx.stroke();
        }
        if (this.type === "regenerator") {
          ctx.strokeStyle = "rgba(100,255,100,0.3)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(0, 0, this.hitRadius + 6, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Health bar (fixed orientation)
        ctx.rotate(-Math.PI / 2);
        ctx.fillStyle = "red";
        ctx.fillRect(-this.hitRadius, -this.hitRadius - 12, this.hitRadius * 2, 5);
        ctx.fillStyle = "lime";
        ctx.fillRect(
          -this.hitRadius,
          -this.hitRadius - 12,
          (this.health / this.maxHealth) * this.hitRadius * 2,
          5
        );

        ctx.restore();
      }



    }


    class BossEnemy {
      constructor(path, waveNumber = 10) {
        this.path = path;
        this.currentPathIndex = 0;
        this.x = path[0].x;
        this.y = path[0].y;
        this.hitRadius = 30;
        this.dead = false;
        this.speed = 0.5 + 0.1 * (waveNumber / 10);
        this.health = 5000 + waveNumber * 600;
        this.maxHealth = this.health;
        this.reward = 150 + waveNumber * 20;
      }

      update() {
        if (this.dead) return;
        const target = this.path[this.currentPathIndex + 1];
        if (!target) {
          this.dead = true;
          lives--;
          showMessage("BOSS escaped! -1 Life", 1500);
          return;
        }


        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist < this.speed * gameSpeed) {
          this.x = target.x;
          this.y = target.y;
          this.currentPathIndex++;
        } else {
          this.x += (dx / dist) * this.speed * gameSpeed;
          this.y += (dy / dist) * this.speed * gameSpeed;
        }

        if (this.health <= 0) {
          this.dead = true;
          money += this.reward;
          showMessage(`üí∞ Boss defeated! +$${this.reward}`, 2500);
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // Face the path
        const next = this.path[this.currentPathIndex + 1];
        if (next) {
          const dx = next.x - this.x;
          const dy = next.y - this.y;
          ctx.rotate(Math.atan2(dy, dx));
        }

        // Draw giant gunship
        if (bossSprite.complete) {
          ctx.drawImage(bossSprite, -64, -64, 128, 128);
        }

        // Health bar (fixed orientation)
        ctx.rotate(-Math.PI / 2);
        ctx.fillStyle = "#800";
        ctx.fillRect(-40, -56, 80, 10);
        ctx.fillStyle = "#0f0";
        ctx.fillRect(-40, -56, (this.health / this.maxHealth) * 80, 10);

        ctx.restore();
      }


    }

    class BurnEffect {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.timer = 0;
      }

      update() {
        this.timer += gameSpeed;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.globalAlpha = 0.6 - (this.timer % 20) * 0.03;
        ctx.fillStyle = "orange";
        ctx.beginPath();
        ctx.arc(0, 0, 6 + Math.sin(this.timer * 0.2) * 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      get finished() {
        return this.timer > 60;
      }
    }

    class SunBeamEffect {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.timer = 0;
        this.finished = false;
      }

      update() {
        this.timer += gameSpeed;
        if (this.timer > 20) this.finished = true;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.globalAlpha = 1 - this.timer / 20;
        for (let i = 0; i < 12; i++) {
          const angle = (Math.PI * 2 * i) / 12;
          ctx.strokeStyle = `rgba(255, 255, 100, ${1 - this.timer / 20})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(angle) * 40, Math.sin(angle) * 40);
          ctx.stroke();
        }
        ctx.restore();
      }
    }

    class RecoilBlast {
      constructor(x, y, angle) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.timer = 0;
        this.finished = false;
      }

      update() {
        this.timer += gameSpeed;
        if (this.timer > 15) this.finished = true;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.globalAlpha = 1 - this.timer / 15;
        ctx.fillStyle = "orange";
        ctx.beginPath();
        ctx.arc(10, 0, 6 + this.timer / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }




    function drawRiver() {
      // Outer grass-border path
      ctx.strokeStyle = "#000000"; // jungle border
      ctx.lineWidth = 36;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(enemyPath[0].x, enemyPath[0].y);
      enemyPath.forEach((p) => ctx.lineTo(p.x, p.y));
      ctx.stroke();

      // Middle path (dirt color)
      ctx.strokeStyle = "#33322F"; // Jungle dirt brown
      ctx.lineWidth = 26;
      ctx.beginPath();
      ctx.moveTo(enemyPath[0].x, enemyPath[0].y);
      enemyPath.forEach((p) => ctx.lineTo(p.x, p.y));
      ctx.stroke();

      // Inner line to mark center of the road
      ctx.strokeStyle = "#F5B20C"; // Lighter dirt center
      ctx.lineWidth = 4;
      ctx.setLineDash([10, 8]);
      ctx.beginPath();
      ctx.moveTo(enemyPath[0].x, enemyPath[0].y);
      enemyPath.forEach((p) => ctx.lineTo(p.x, p.y));
      ctx.stroke();
      ctx.setLineDash([]);
    }






    function drawEnemyPath() {
      ctx.strokeStyle = "#F5B20C";
      ctx.lineWidth = 4;
      ctx.setLineDash([8, 4]);
      ctx.beginPath();
      ctx.moveTo(enemyPath[0].x, enemyPath[0].y);
      enemyPath.slice(1).forEach((p) => ctx.lineTo(p.x, p.y));
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function startWave() {
      if (spawning) return;
      waveNumber++;

      if (waveNumber === 25) {
        enemyTypes.push("specter", "inferno");
      }
      if (waveNumber >= 25 && waveNumber % 5 === 0) {
        const titanCount = Math.floor((waveNumber - 25) / 5) + 2;

        for (let i = 0; i < titanCount; i++) {
          enemies.push(new Enemy(enemyPath, "titan", waveNumber));
        }

        // Only subtract if wave includes normal spawns
        if (enemiesToSpawn > 0) {
          enemiesToSpawn -= titanCount;
          if (enemiesToSpawn < 0) enemiesToSpawn = 0;
        }

        showMessage(`‚ö†Ô∏è ${titanCount} Titan${titanCount > 1 ? "s" : ""} incoming!`, 2500);
      }

      let waveEnemies = {};
      

      if (!enemyTypes.includes("normal")) {
        enemyTypes = ["normal", "fast", "armoredBoss", "shielded", "regenerator", "flying"];
      }

      if (waveNumber % 10 === 0) {
        enemiesToSpawn = 0;
        enemies.push(new BossEnemy(enemyPath, waveNumber));
        showMessage(`üëë BOSS WAVE ${waveNumber}! Prepare for battle!`, 3000);
      } else {
        enemiesToSpawn = 5 + waveNumber * 4;
      }

      if (waveNumber >= 25 && waveNumber % 5 === 0) {
        enemies.push(new Enemy(enemyPath, "titan", waveNumber));
      if (enemiesToSpawn > 0) enemiesToSpawn -= 1;
        showMessage("‚ö†Ô∏è Titan incoming!", 2500);
      }


      spawning = true;
      spawnTimer = 0;
      showMessage(`Wave ${waveNumber} started!`, 2000);
    }

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect(),
            mx = e.clientX - rect.left,
            my = e.clientY - rect.top;

      if (placingTower && selectedTowerType) {
        // Check path proximity
        let onPath = false;
        for (let i = 0; i < enemyPath.length - 1; i++) {
          const p = enemyPath[i], q = enemyPath[i + 1];
          const dx = q.x - p.x, dy = q.y - p.y;
          const t = ((mx - p.x) * dx + (my - p.y) * dy) / (dx * dx + dy * dy);
          if (t > 0 && t < 1) {
            const cx = p.x + t * dx, cy = p.y + t * dy;
            if (distance(mx, my, cx, cy) < 40) onPath = true;
          }
        }
        if (onPath) return showMessage("Cannot place on the path!", 1000);

        if (towers.some(t => distance(t.x, t.y, mx, my) < 40)) return showMessage("Too close to another tower!", 1000);
        const cost = towerCosts[selectedTowerType];
        if (money < cost) return showMessage("Not enough money!", 1000);

        money -= cost;
        towers.push(new Tower(mx, my, selectedTowerType));
        placingTower = false;
        selectedTowerType = null;
        updateDisplays();
        return;
      }

      // Tower selection / upgrade panel
      selectedTower = towers.find((t) => distance(mx, my, t.x, t.y) < 20) || null;
      upgradePanel.style.display = selectedTower ? "block" : "none";
      if (selectedTower) {

        const type = selectedTower.type;
        upgrade1Btn.textContent = `Path 1: ${upgradeDescriptions[type][0]} ($${upgradeCosts[type][0]})`;
        upgrade2Btn.textContent = `Path 2: ${upgradeDescriptions[type][1]} ($${upgradeCosts[type][1]})`;

                // Add icons to panel
        const icons = [];
        const up = selectedTower.upgrades;
        if (up.path1 > 0) icons.push(upgradePaths[selectedTower.type].path1[1]);
        if (up.path2 > 0) icons.push(upgradePaths[selectedTower.type].path2[1]);
        document.getElementById("upgrade-icons").innerHTML = icons.join(" ");


        if (selectedTower.upgrades.path1 > 0) {
          upgrade2Btn.disabled = true;
          upgrade2Btn.textContent += " (Locked)";
        } else if (selectedTower.upgrades.path2 > 0) {
          upgrade1Btn.disabled = true;
          upgrade1Btn.textContent += " (Locked)";
        } else {
          upgrade1Btn.disabled = false;
          upgrade2Btn.disabled = false;
        }



        sellBtn.textContent = `Sell Tower ($${Math.floor(towerCosts[selectedTower.type] / 2)})`;
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect(),
            mx = e.clientX - rect.left,
            my = e.clientY - rect.top;

      hoveredTower = towers.find((t) => distance(mx, my, t.x, t.y) < 20) || null;
        if (placingTower) {
          placementX = mx;
          placementY = my;
        }

    });

    towerMenu.addEventListener("click", (e) => {
      if (e.target.tagName !== "BUTTON") return;
      const type = e.target.dataset.tower;
      if (towerCosts[type]) {
        selectedTowerType = type;
        placingTower = true;
        selectedTower = null;
        upgradePanel.style.display = "none";
        showMessage(`Placing ${type} tower`, 1500);
      }
    });


    towerMenu.addEventListener("mouseover", (e) => {
      if (e.target.tagName !== "BUTTON") return;
      const towerType = e.target.dataset.tower;
      const cost = towerCosts[towerType];
      const desc = upgradeDescriptions[towerType] || ["", ""];

      const previewBox = document.getElementById("tower-preview");
      const nameBox = document.getElementById("preview-name");
      const costBox = document.getElementById("preview-cost");
      const statBox = document.getElementById("preview-stats");

      nameBox.textContent = towerType + " Tower";
      costBox.textContent = `Cost: $${cost}`;
      statBox.innerHTML = `
        <li>üõ† Path 1: ${desc[0]}</li>
        <li>üß™ Path 2: ${desc[1]}</li>
      `;
      previewBox.style.display = "block";
    });

    towerMenu.addEventListener("mouseout", (e) => {
      if (e.target.tagName !== "BUTTON") return;
      document.getElementById("tower-preview").style.display = "none";
    });



    upgrade1Btn.addEventListener("click", () => {
      if (!selectedTower) return;
      const type = selectedTower.type;
      const cost = upgradeCosts[type][0];

      if (selectedTower.upgrades.path2 > 0) {
        return showMessage("‚ùå You already upgraded Path 2!", 1500);
      }

      if (money < cost) return showMessage("Not enough money!", 1500);
      money -= cost;
      selectedTower.level++;
      selectedTower.upgrades.path1++;

      upgradeEffects[type][0](selectedTower);

      updateDisplays();
      showMessage(`‚úÖ ${type} Path‚ÄØ1 Upgraded!`, 1500);
    });



    upgrade2Btn.addEventListener("click", () => {
      if (!selectedTower) return;
      const type = selectedTower.type;
      const cost = upgradeCosts[type][1];

      if (selectedTower.upgrades.path1 > 0) {
        return showMessage("‚ùå You already upgraded Path 1!", 1500);
      }

      if (money < cost) return showMessage("Not enough money!", 1500);
      money -= cost;
      selectedTower.level++;
      selectedTower.upgrades.path2++;

      switch (type) {
        case "basic":
          selectedTower.damage += 15;
          break;
        case "sniper":
          selectedTower.reloadSpeed = Math.max(5, selectedTower.reloadSpeed - 10);
          break;
        case "cannon":
          selectedTower.range += 25;
          break;
        case "flame":
          selectedTower.range += 25;
          selectedTower.damage += 3;
          break;
        case "ice":
          selectedTower.damage += 12;
          break;
        case "tesla":
          selectedTower.reloadSpeed = Math.max(6, selectedTower.reloadSpeed - 6);
          break;
        case "missile":
          selectedTower.reloadSpeed = Math.max(25, selectedTower.reloadSpeed - 20);
          break;
        case "sniperElite":
          selectedTower.damage += 40;
          break;
        case "Obsidian":
          selectedTower.damage += 25;
          break;
        case "Nova":
          selectedTower.reloadSpeed = Math.max(10, selectedTower.reloadSpeed - 8);
          break;
        case "poison":
          selectedTower.damage += 12;
          break;
        case "railgun":
          selectedTower.reloadSpeed = Math.max(8, selectedTower.reloadSpeed - 10);
          break;
      }

      updateDisplays();
      showMessage(`‚úÖ ${type} Path‚ÄØ2 Upgraded!`, 1500);
    });



    sellBtn.addEventListener("click", () => {
      if (!selectedTower) return;
      const refund = Math.floor(towerCosts[selectedTower.type] / 2);
      money += refund;
      towers = towers.filter((t) => t !== selectedTower);
      selectedTower = null;
      upgradePanel.style.display = "none";
      updateDisplays();
      showMessage(`Sold for $${refund}`, 1500);
    });

    startBtn.addEventListener("click", startWave);

    stopBtn.addEventListener("click", () => {
      gamePaused = !gamePaused;
      stopBtn.textContent = gamePaused ? "Resume" : "Pause";
      showMessage(gamePaused ? "Game Paused" : "Game Resumed", 1000);
    });

    autoBtn.addEventListener("click", () => {
      autoStart = !autoStart;
      autoBtn.textContent = `Auto Start: ${autoStart ? "ON" : "OFF"}`;
    });

    speedBtn.addEventListener("click", () => {
      gameSpeed = gameSpeed >= 10 ? 1 : gameSpeed + 1;
      speedBtn.textContent = `Speed: ${gameSpeed}x`;
    });


    function gameLoop() {
      if (lives <= 0) {
        gamePaused = true;
        showMessage("Game Over!", 5000);
      }

      if (!gamePaused) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrassBackground();
        drawRiver();
        drawEnemyPath();

            if (placingTower && selectedTowerType) {
              ctx.save();




              let towerRange = (() => {
                switch (selectedTowerType) {
                  case "sniper": return 200;
                  case "cannon": return 120;
                  case "flame": return 80;
                  case "ice": return 90;
                  case "tesla": return 110;
                  case "missile": return 160;
                  case "sniperElite": return 250;
                  case "Obsidian": return 160;
                  case "Nova": return 100;
                  case "poison": return 100;
                  case "railgun": return 400;
                  case "hyperLaser": return 280;
                  case "omegaCannon": return 280;
                  case "basic": default: return 100;
                }
              })();




              
              ctx.strokeStyle = "#0f0";
              let valid = true;

              for (let i = 0; i < enemyPath.length - 1; i++) {
                const p = enemyPath[i], q = enemyPath[i + 1];
                const dx = q.x - p.x, dy = q.y - p.y;
                const t = ((placementX - p.x) * dx + (placementY - p.y) * dy) / (dx * dx + dy * dy);
                if (t > 0 && t < 1) {
                  const cx = p.x + t * dx, cy = p.y + t * dy;
                  if (distance(placementX, placementY, cx, cy) < 40) valid = false;
                }
              }
              if (towers.some(t => distance(t.x, t.y, placementX, placementY) < 40)) valid = false;

              ctx.strokeStyle = valid ? "#0f0" : "#f00";
              ctx.globalAlpha = 0.3;
              ctx.beginPath();
              ctx.arc(placementX, placementY, towerRange, 0, Math.PI * 2);
              ctx.fillStyle = valid ? "#0f04" : "#f004";
              ctx.fill();
              ctx.stroke();
              ctx.restore();
            }


        if (spawning && enemiesToSpawn > 0) {
          spawnTimer--;
          if (spawnTimer <= 0) {
            // Expand enemy types if needed
            if (waveNumber > 5 && enemyTypes.length < 6) {
              enemyTypes = ["normal", "fast", "armoredBoss", "shielded", "regenerator", "flying"];
            }

            const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            enemies.push(new Enemy(enemyPath, type, waveNumber));
            enemiesToSpawn--;

            // Reset spawn timer
            spawnTimer = Math.max(10, 40 - waveNumber * 2);
          }
        }


        if (spawning && enemiesToSpawn === 0 && enemies.length === 0) {
          spawning = false;
          if (autoStart) startWave();
        }

        towers.forEach((t) => t.update());
        bullets.forEach((b) => b.update());
        enemies.forEach((e) => e.update());
        effects.forEach((e) => e.update());


        effects = effects.filter((e) => !e.finished);
        bullets = bullets.filter((b) => !b.dead);        
        enemies = enemies.filter((e) => !e.dead || e.health > 0);



        towers.forEach((t) => t.draw());
        enemies.forEach((e) => e.draw());
        bullets.forEach((b) => b.draw());
        effects.forEach((e) => e.draw());
       

        updateDisplays();
      }

      requestAnimationFrame(gameLoop);
    }

    updateDisplays();
    startWave();
    requestAnimationFrame(gameLoop);

    const enemyInfoBtn = document.getElementById("enemyInfoBtn");
    const enemyInfoPanel = document.getElementById("enemy-info-panel");
    const enemyList = document.getElementById("enemy-list");
    const closeEnemyInfoBtn = document.getElementById("closeEnemyInfoBtn");

    // Add your enemy descriptions:
    const enemyDescriptions = {
      normal: "Standard tank ‚Äî balanced health & speed.",
      fast: "Fast-moving jeep ‚Äî low health, quick.",
      armoredBoss: "Heavy tank with strong armor.",
      shielded: "Tank with a protective forcefield.",
      regenerator: "APC that regenerates health over time.",
      flying: "Jet that flies over obstacles.",
      titan: "Massive dropship ‚Äî huge health pool.",
      specter: "Stealth drone that evades bullets.",
      inferno: "Flame mech with burn aura."
    };

    enemyInfoBtn.addEventListener("click", () => {
      enemyList.innerHTML = "";
      Object.keys(enemySprites).forEach(type => {
        const card = document.createElement("div");
        card.className = "enemy-card";
        const img = enemySprites[type].cloneNode();
        const name = document.createElement("strong");
        name.textContent = type.charAt(0).toUpperCase() + type.slice(1);
        const desc = document.createElement("p");
        desc.textContent = enemyDescriptions[type] || "No description.";
        card.appendChild(img);
        card.appendChild(name);
        card.appendChild(desc);
        enemyList.appendChild(card);
      });
      enemyInfoPanel.style.display = "block";
    });

    closeEnemyInfoBtn.addEventListener("click", () => {
      enemyInfoPanel.style.display = "none";
    });


  })();
  </script>
</body>
</html>
